=== director_token.json ===
{"user_id": "@lunabot:localhost", "access_token": "syt_bHVuYWJvdA_OcIVWrozQzoQzTkealVs_4eQJHP", "device_id": "SYLZUYWURQ"}
=== luna.md ===
luna.md

# Luna System Conversation Recap

This file consolidates the **three levels** of summarization and explanation into a single document. Each level offers a progressively deeper view of the Luna + Matrix ecosystem, culminating in a detailed architecture overview.

---

## **Level 1: High-Level Summary**

We have developed a **Matrix-based chatbot system** named **Luna**. Luna:

1. **Connects to a Synapse (Matrix) server** to send and receive messages in real time.  
2. **Interacts with GPT** (e.g., OpenAI models) to provide intelligent replies based on recent chat context.  
3. **Maintains a local store (CSV or DB)** of inbound and outbound messages, plus tokens for synchronization with the Matrix server.  
4. **Provides a command-driven console** (in a separate thread) where an admin can manage rooms, invite users, rotate logs, or purge/re-seed data.  

### Why We Did This
- **Real-time chat**: Matrix-NIO handles the real-time synchronization.  
- **Flexible GPT integration**: We can adjust how many recent messages or summarized context to pass to GPT.  
- **Multi-agent expansions**: We can have multiple bots (or personas) working in different channels.  
- **Ease of experimentation**: Admin commands let us quickly create or invite new users, fetch missed messages, or rotate logs.

### High-Level Value
This system can power:
- Creative storytelling: letting Luna participate in a multi-user role-play.  
- Educational scenarios: a teacher bot in a dedicated room with students.  
- Multi-agent expansions: specialized “math bot,” “story bot,” “lore bot,” each with unique system prompts.  

---

## **Level 2: Deeper Detail**

In more detail, the conversation led us to discuss:

1. **On-Room Message Triage**  
   - Luna ignores her own messages, only replies automatically in 2-person rooms, and checks for mentions (“luna,” “lunabot”) in group rooms.

2. **Local Data Handling**  
   - We store every inbound/outbound message in `luna_messages.csv` or a DB.  
   - We keep a sync token (`sync_token.json`) to fetch only new events if needed.

3. **Console and Command Flow**  
   - A background console thread listens for user commands:  
     - _create_channel_, _add_participant_, _fetch_all_, _fetch_new_, etc.  
   - These commands schedule async tasks on the main event loop.  
   - Results are printed back to the console.

4. **Summarization & Context**  
   - Because GPT has a token limit, we plan to chunk or summarize older logs.  
   - Possibly embed them so relevant parts can be retrieved.  
   - This ensures Luna’s knowledge of prior events grows without losing coherence in GPT prompts.

5. **Testing & Expansion**  
   - We can build **automated regression tests** that simulate console inputs, check logs, or run ephemeral servers for integration checks.  
   - This system can scale to multiple “bot personas,” each an account on the same Matrix server or a single account with multiple “modes.”

### Example Use Cases
- **Storytelling**: The user might say, “@lunabot, describe the next scene!” If multiple sessions have built up a plot, Luna consults the local store or sync data, calls GPT with a summarized context, and replies with a continuing narrative.  
- **Teacher & Student**: A teacher bot in a private channel with students. The teacher references the conversation logs for context-based tips.

### Why This Design
- **Matrix**: We want open-source, real-time messaging with robust identity (rooms, invites, etc.).  
- **Asynchronous**: “asyncio” plus `matrix-nio` handles large concurrency without blocking.  
- **Local CSV**: Quick, simple data store for now. Could replace with SQL if needed.  
- **Flexible**: The command router is easy to extend with new admin commands (e.g., “purge_and_seed,” “list_channels,” etc.).

---

## **Level 3: Detailed Architecture Overview**

Below is a **detailed** technical breakdown from bottom to top.

### 1. Matrix Server Layer
- **Synapse** or another Matrix homeserver runs locally or on a host.  
- Houses user accounts (like `@lunabot:localhost`).  
- Manages real-time message flow, invitations, and authentication.  
- On startup, the console can do “purge_and_seed” to wipe the server DB, re-register admin users, etc.

### 2. Luna’s Python Client

**2.1. AsyncClient Setup**  
- We use **`matrix-nio`** to create `AsyncClient(homeserver_url=..., user=...)`.  
- Luna has a `director_token.json` file storing `access_token` for reconnection.  
- On first run, if no token is found, Luna does a password login and saves the new token.

**2.2. on_room_message**  
- Called every time the Matrix server sends a `RoomMessageText` event to Luna.  
- Steps:
  1. **Ignore own messages** (avoid self-loop).  
  2. **Check participant count** in that room:
     - If 2 people, respond automatically.  
     - If 3 or more, respond only if “luna” is mentioned.  
  3. **Store inbound message** into CSV/DB.  
  4. **Fetch recent messages** (e.g. last 10) for context.  
  5. **Add system instructions** and user’s latest text => GPT.  
  6. **Send GPT’s reply** back to room, also store it in CSV/DB.

**2.3. Database or CSV**  
- In real-time, each message is appended to “luna_messages.csv.”  
- We can do `fetch_all` to get older messages from the server, or `fetch_new` using the sync token.  
- If the server was offline or Luna was offline, we still can do a sync step to fill gaps.

### 3. Summaries & Larger Context
- We have not fully implemented chunking or embedding but the plan is:  
  - Summarize older logs so GPT’s token window stays manageable.  
  - Potentially store partial summaries in a separate file or columns for quick reference.  
  - For multi-hour or multi-day role plays, have a top-level “chapter summary,” and pass it into the system prompt.

### 4. Console & Admin Commands

**4.1. Console Thread**  
- A separate Python thread runs `console_loop`, using `prompt_toolkit` for tab-completion.  
- The user sees a `[luna-app] timestamp (#N) % ` prompt.  
- They type commands like “create_channel MyRoom” or “add_participant !abc:localhost @someuser:localhost.”

**4.2. Command Router**  
- A dictionary mapping strings (like “fetch_new”) to functions (like `cmd_fetch_new`).  
- Each command function parses arguments, schedules an async call in the event loop, and prints results.

**4.3. Commands & Handlers**  
- **`cmd_create_channel`**: calls `luna_functions.create_channel(...)`.  
- **`cmd_add_participant`**: calls `luna_functions.add_participant(...)`.  
- **`cmd_fetch_all`**: calls `luna_functions.fetch_all_messages_once(...)`.  
- **`cmd_rotate_logs`**: rotates `server.log`, re-initializes logging.  
- **`cmd_purge_and_seed`**: destructively resets the server DB and local store, re-registers the needed accounts.

### 5. Testing & Multi-Agent Vision

**5.1. Automated Testing**  
- We can script console commands to run in a pseudo-terminal.  
- Confirm expected outputs or log messages.  
- Potentially spin up a local Synapse server container on each test run.

**5.2. Multi-Agent**  
- We can register more Matrix user accounts, each with a different GPT personality or specialized knowledge.  
- They can join the same or different channels, replying according to their system prompts.

**5.3. Summaries for Large Projects**  
- Over time, we can store big conversation logs and chunk them into “chapters.”  
- GPT calls can retrieve relevant summary chapters plus the last few messages for immediate context.  

---

## Conclusion

This document presents **all three levels**:  
1. A short, high-level overview of **Luna’s** purpose and value.  
2. A deeper dive into the system’s features, triage logic, and local data handling.  
3. A thorough **architecture overview**, covering each layer from the Matrix server up to multi-agent expansions and potential summarization strategies.

All told, this system stands as a flexible, extensible chatbot architecture, combining open-source messaging (Matrix) with GPT’s generative power, supported by a command-driven console for administration and future expansions into multi-agent creative or educational projects.

Next Phase Requirements Document
1. Objective
Upgrade Luna to support:

Summoning new bot personas (each as a unique Matrix user).
Dispatching messages properly so bots only respond in direct chats or when explicitly mentioned in a group.
Ping-Pong Suppression to prevent infinite loops or repetitive back-and-forth among bots.
2. Key Features & Flow
2.1. Summoning (Spawning)
Description: Luna should be able to create (“spawn”) a new bot persona on demand, complete with a Matrix user account and an entry in the local personality store.
User Story: “As a user, I can instruct Luna to summon a new bot. Luna will create the Matrix user, a channel if needed, invite the bot to that channel, and store its persona in personalities.json or equivalent DB.”
Requirements:
Create a new user in Matrix (via register_new_matrix_user or a Synapse Admin API).
Must confirm success (e.g., check the response from the admin API).
(Optional) Create a channel if no existing channel is specified.
If a channel is passed in or chosen by the user, skip creation.
Invite the newly created user to the channel.
Store the bot’s personality in a local data file (e.g. personalities.json), keyed by @botname:localhost.
Must include at least:
displayname (string)
system_prompt (string)
traits (dict or map of Big Five or other characteristics)
created_at (timestamp)
channel_id or list of room IDs
The format is flexible for future extension.
2.2. Despawning
Description: Luna should be able to remove (“despawn”) a bot persona from the environment and local store.
User Story: “As an admin, I can instruct Luna to despawn a bot so that it no longer appears in the channel, user lists, or local store.”
Requirements:
Remove the user from the channel(s) (via room_kick or room_leave).
Delete the Matrix user from the homeserver (via Synapse Admin API, DELETE /_synapse/admin/v2/users/<userID>).
Remove the persona from the local data store (personalities.json or DB).
2.3. Dispatch Rules
Description: Each bot, including Luna, only responds automatically in:
Direct (2-participant) rooms: always respond.
Group rooms (3+ participants): respond only if explicitly mentioned (e.g., “@botname:localhost”).
User Story: “As a user in a group channel, I only want the bot to respond if I mention it. As a user in a DM with the bot, it should always reply to me.”
Requirements:
Participant Count Check: If count == 2, respond unconditionally.
Mention Check: If count >= 3, parse message for @botUserID or a recognized handle. If found, respond; otherwise, ignore.
Ignore Own Messages: A bot should never respond to its own text to prevent loops.
2.4. Ping-Pong Suppression
Description: Prevent runaway or infinite loops when bots mention each other repeatedly, or when users keep bouncing short messages.
Proposal: “If any chain of messages in a channel contains exactly the same users in the same repeating pattern 5 times, the next message from each user is suppressed.”
For instance, if @botA and @botB keep alternating messages 5 times with no other participants joining, the bot conversation is suppressed or halted on the 6th attempt.
User Story: “As an admin, I want to avoid endless spam if two or more bots inadvertently mention each other in a loop.”
Requirements:
Track recent messages in a channel, focusing on the participants in chronological order.
Identify repeating patterns of the same subset of participants (e.g., @botA → @botB → @botA → @botB…).
When this chain occurs 5 times in a row (or any threshold you define), automatically suppress the next message from those same participants.
“Suppress” might mean refusing to send the response, or sending a warning message about ping-pong limit reached.
Reset the chain if a new user enters the conversation or after some time passes (configurable reset).
Note: This is a simple approach but ensures a clear, user-friendly rule. You can adjust the threshold or the definition of “exactly the same users” to refine behavior.

3. Data Storage
Personality Store:
File: personalities.json (or DB).
Keys: @bot:localhost (Matrix IDs).
Values: flexible JSON with fields for system prompts, traits, timestamps, notes, etc.
Local Message Log:
Continue storing inbound/outbound messages (e.g. luna_messages.csv) or a DB. This helps with:
Dispatch logic (check the last few messages to detect ping-pong patterns).
Summaries for GPT context if needed.
4. Architecture & Sequence Diagrams (Conceptual)
4.1. Summoning Sequence
User: “Luna, create new bot named @scoutbot:localhost.”
Luna (Controller):
a. create_user(“scoutbot”, …) via admin API
b. create_room(“ScoutBotChannel”) if needed
c. invite_user_to_room(“@scoutbot:localhost”, “!someID:localhost”)
d. store_personality(“@scoutbot:localhost”, {...})
4.2. Despawning Sequence
User: “Luna, despawn @scoutbot:localhost.”
Luna (Controller):
a. kick or leave the room (room_kick)
b. delete_user_via_admin_api(“@scoutbot:localhost”)
c. remove from personalities.json
4.3. Dispatch Flow (Inbound Message)
Matrix → Bot Callback: on_room_message(room, event)
Bot checks participant count.
If 2-person room → respond. If 3+ → respond only if “@botID” in message text.
Check ping-pong pattern in local message log. If limit reached, suppress.
Otherwise → build GPT prompt, generate response, store it in local log, send to room.
5. Non-Functional Requirements
Performance:
Summoning a new bot (user creation + channel invite) should complete within a few seconds.
Logging messages and personalities to disk should not block the main event loop excessively.
Security:
Only authorized admins can spawn or despawn bots.
The admin token for user creation/deletion must be kept secure in director_token.json.
Reliability:
If the server or Luna is restarted, the personality data should still be available.
If the creation fails partially (e.g., user is created but not invited), a rollback or cleanup step should be possible.
Extensibility:
The personality store is JSON-based and can accommodate new fields (traits, system prompts, etc.) as the system evolves.
Maintainability:
Keep the summoning logic in a dedicated function (e.g., spawn_persona(...)) for clarity.
Keep dispatch/ping-pong logic in the message callback or a dedicated “routing” module.
6. Testing & Validation
Summoning Test:
Summon a bot, confirm user appears in “list_users,” is in the designated channel, and persona is in personalities.json.
Despawning Test:
Despawn that bot, confirm user is gone from “list_users,” removed from channel participants, and removed from personalities.json.
Dispatch:
In a group room of 3+ participants, ensure the bot remains silent until someone tags “@botname:localhost.”
In a DM with the bot, ensure it responds automatically to any message.
Ping-Pong Suppression:
Intentionally create a repeating sequence of messages between two or more bots. After X repeated patterns, confirm the system suppresses further messages or logs a warning.
Ensure it resets once a new user enters the conversation or after a certain cooldown.
7. Conclusion & Next Steps
With these requirements, Luna can:

Spawn new bots (Matrix user + local personality store),
Despawning them cleanly,
Dispatch only when relevant,
Prevent infinite loops via simple, user-friendly ping-pong suppression rules.
Next Steps:

Implement each step in code, likely in luna_functions.py and console_functions.py.
Test each scenario in your dev environment.
Validate performance, security, and user experience.
Once completed, you’ll have a robust multi-bot ecosystem where each new persona truly “exists” in Matrix, and your channels stay sane thanks to mention-based dispatch and loop suppression.
=== luna.py ===
"""
luna.py

- Configures logging (console + file)
- Creates one main event loop
- Spawns the console in a background thread (reads user commands, schedules coroutines)
- Runs the 'main_logic' which logs in (reusing token or password) and syncs forever
"""

import asyncio
import sys
import logging
import threading
from src.console_apparatus import console_loop
from src.cmd_shutdown import init_shutdown, SHOULD_SHUT_DOWN

from nio import RoomMessageText, InviteMemberEvent, AsyncClient
from src.luna_functions import (
    on_room_message,
    on_invite_event,
    load_or_login_client,
)

# We'll store the main event loop globally so both the console thread
# and the Director logic can access it.
MAIN_LOOP = None


def configure_logging():
    """
    Configure Python's logging so logs go to both console and server.log.
    """
    logger = logging.getLogger(__name__)
    logging.getLogger("nio.responses").setLevel(logging.CRITICAL)
    logger.debug("Entering configure_logging function.")

    root_logger = logging.getLogger()
    root_logger.setLevel(logging.DEBUG)  # Overall log level
    logger.debug("Set root logger level to DEBUG.")

    formatter = logging.Formatter("%(asctime)s [%(levelname)s] %(name)s: %(message)s")
    logger.debug("Formatter for logs created.")

    file_handler = logging.FileHandler("server.log", mode="a")  # Append to server.log
    file_handler.setLevel(logging.DEBUG)  # Store everything (DEBUG+) in the file
    file_handler.setFormatter(formatter)
    root_logger.addHandler(file_handler)
    logger.debug("Added file handler to root logger. Logging to 'server.log' at DEBUG level.")

    logger.debug("Exiting configure_logging function.")


def start_console_thread(loop):
    """
    Spawn the console input loop in a background thread,
    passing in `loop` so commands can schedule tasks on that loop.
    """
    logger = logging.getLogger(__name__)
    logger.debug("Entering start_console_thread function.")

    try:
        thread = threading.Thread(target=lambda: console_loop(loop), daemon=True)
        thread.start()
        logger.info("Console thread started successfully.")
    except Exception as e:
        logger.exception(f"Failed to start console thread: {e}")

    logger.debug("Exiting start_console_thread function.")


async def main_logic():
    logger = logging.getLogger(__name__)
    logger.debug("Entering main_logic function...")

    # 1. Acquire client
    client: AsyncClient = await load_or_login_client(
        homeserver_url="http://localhost:8008",
        username="lunabot",
        password="12345"
    )

    # 2. Register callbacks
    client.add_event_callback(on_room_message, RoomMessageText)
    client.add_event_callback(on_invite_event, InviteMemberEvent)

    # 3. Repeatedly sync in short intervals, checking the shutdown flag
    logger.debug("Starting short sync loop; will exit when SHOULD_SHUT_DOWN = True.")
    while not SHOULD_SHUT_DOWN:
        # A single sync that times out after (say) 5 seconds
        try:
            await client.sync(timeout=5000)
        except Exception as e:
            logger.exception(f"Error in client.sync: {e}")

    # If we reach here, user triggered a shutdown or an error occurred
    logger.info("main_logic loop exiting. Closing client connection...")
    await client.close()
    logger.debug("Client closed. main_logic() is returning.")

def luna():
    """
    Orchestrates everything:
    - Configure logging
    - Create the main event loop
    - Start the console thread (which schedules coroutines on the loop)
    - Run `main_logic()` until complete (i.e., forever, unless Ctrl+C, etc.)
    """
    logger = logging.getLogger(__name__)
    logger.debug("Entering luna() function.")

    # 1. Configure logging
    configure_logging()
    logger.debug("Logging configuration complete.")

    # 2. Create our own event loop
    logger.debug("Creating a new asyncio event loop.")
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    logger.debug("Set this new loop as the default event loop for the current thread.")

    # 2) Initialize shutdown helper with this loop
    init_shutdown(loop)

    global MAIN_LOOP
    MAIN_LOOP = loop  # Store in a global
    logger.debug("Stored reference to the new loop in MAIN_LOOP.")

    # 3. Start the console in a background thread
    start_console_thread(loop)
    logger.debug("Console thread has been initiated. Returning to main thread.")

    # 4. Run the main async logic (token-based login & sync) on this loop
    try:
        logger.info("Starting main_logic coroutine.")
        loop.run_until_complete(main_logic())
    except KeyboardInterrupt:
        logger.warning("KeyboardInterrupt received. Shutting down Director.")
    except Exception as e:
        logger.exception(f"An unexpected exception occurred in main_logic: {e}")
    finally:
        logger.debug("Preparing to close the event loop.")
        loop.close()
        logger.info("Event loop closed. Exiting main function.")

if __name__ == "__main__":
    luna()

=== requirements.txt ===

=== src/ai_functions.py ===
"""
ai_functions.py

Provides a minimal interface for sending prompts to the OpenAI API
and receiving responses. Includes logging statements for transparency.
"""

import os
import logging
import openai
from dotenv import load_dotenv
from openai import AsyncOpenAI

# Set up logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)  # Adjust as needed
logging.getLogger("nio.responses").setLevel(logging.CRITICAL)  # Suppress noisy nio responses

# Load environment variables from a .env file
load_dotenv("/Users/evanrobinson/Documents/Luna2/luna/src/.env")


OPENAI_API_KEY = os.getenv("OPENAI_API_KEY") # Load the API key from the environment
client = AsyncOpenAI(api_key=os.getenv("OPENAI_API_KEY")) # Create an AsyncOpenAI client
openai.api_key = OPENAI_API_KEY # Set the API key for OpenAI


if not OPENAI_API_KEY:
    logger.warning("No OPENAI_API_KEY found in environment variables.")




async def get_gpt_response(
    context: list,
    model: str = "gpt-4",
    temperature: float = 0.7,
    max_tokens: int = 300
) -> str:
    """
    Sends a conversation context to GPT and retrieves the response.

    Returns a user-friendly, first-person error message if something goes wrong.
    """

    try:
        response = await client.chat.completions.create(
            model=model,
            messages=context,
            temperature=temperature,
            max_tokens=max_tokens,
        )
        return response.choices[0].message.content

    except openai.error.APIConnectionError as e:
        logger.exception(f"Network problem connecting to OpenAI: {e}")
        return (
            "I'm sorry, but I'm having network troubles at the moment. "
            "Could you check your internet connection and try again soon?"
        )

    except openai.error.RateLimitError as e:
        logger.exception(f"OpenAI rate limit error: {e}")
        return (
            "I'm sorry, I'm a bit overwhelmed right now and have hit my usage limits. "
            "Please try again in a little while!"
        )

    except Exception as e:
        # This catches any other errors
        logger.exception(f"Unhandled error calling OpenAI API: {e}")
        return (
            "I'm sorry, something went wrong on my end. "
            "Could you try again later?"
        )


async def get_gpt_response_dep(context: list, model: str = "gpt-4", temperature: float = 0.7, max_tokens: int = 300) -> str:
    """
    Sends a conversation context to GPT and retrieves the response.

    Args:
        context (list): A list of messages in the format [{"role": "user", "content": "..."}].
        model (str): The GPT model to use (default: "gpt-4").
        temperature (float): Controls randomness (default: 0.7).
        max_tokens (int): The maximum number of tokens in the response (default: 300).

    Returns:
        str: The GPT response.
    """
    logger.debug(f"get_gpt_response called with context: {context}")

    try:
        response = await client.chat.completions.create(
            model=model,
            messages=context,
            temperature=temperature,
            max_tokens=max_tokens,
        )
        return response.choices[0].message.content
    except Exception as e:
        logger.exception(f"Error calling OpenAI API: {e}")
        return "[Error: Unable to generate response.]"




=== src/cmd_shutdown.py ===
# shutdown_helper.py

import asyncio

SHOULD_SHUT_DOWN = False
MAIN_LOOP: asyncio.AbstractEventLoop | None = None

def init_shutdown(loop: asyncio.AbstractEventLoop) -> None:
    """
    Store the given event loop in our local global variable.
    Call this once in luna.py after creating the event loop.
    """
    global MAIN_LOOP
    MAIN_LOOP = loop

def request_shutdown() -> None:
    """
    Sets the SHOULD_SHUT_DOWN flag to True and stops the MAIN_LOOP if it's running.
    """
    global SHOULD_SHUT_DOWN
    SHOULD_SHUT_DOWN = True

    if MAIN_LOOP and MAIN_LOOP.is_running():
        MAIN_LOOP.call_soon_threadsafe(MAIN_LOOP.stop)

=== src/console_apparatus.py ===
import sys
import logging
import asyncio
from datetime import datetime

from prompt_toolkit import PromptSession
from prompt_toolkit.completion import WordCompleter

from src.cmd_shutdown import SHOULD_SHUT_DOWN


# Assuming console_functions.py is in the same package directory.
from . import console_functions

logger = logging.getLogger(__name__)


def console_loop(loop):
    """
    A blocking loop reading console commands in a background thread.
    We'll schedule any async actions on 'loop' via run_coroutine_threadsafe().

    Prompt format:
      [luna] 2025-01-05 14:56 (#1) %

    If the user presses Enter on an empty line, we nudge them
    to type 'help' or 'exit'.

    We use prompt_toolkit for:
      - Arrow keys (history navigation)
      - Tab completion
    """

    # 1) Build a list of known commands for tab-completion
    commands = list(console_functions.COMMAND_ROUTER.keys())

    # 2) Create a WordCompleter from prompt_toolkit
    #    This will do simple prefix matching against our known commands
    commands_completer = WordCompleter(commands, ignore_case=True)

    # 3) Create a PromptSession with that completer
    session = PromptSession(completer=commands_completer)

    command_count = 0

    while not SHOULD_SHUT_DOWN:
        command_count += 1

        # Build a short date/time string
        now_str = datetime.now().strftime('%Y-%m-%d %H:%M')

        # Our custom prompt: e.g. [luna] 2025-01-05 14:56 (#3) %
        prompt_text = f"\n[luna-app] {now_str} (#{command_count}) % "

        try:
            # 4) Read user input using PromptSession
            cmd_line = session.prompt(prompt_text)
        except (EOFError, KeyboardInterrupt):
            # EOFError => user pressed Ctrl+D
            # KeyboardInterrupt => user pressed Ctrl+C
            logger.info("User exited the console (EOF or KeyboardInterrupt).")
            print("\nSYSTEM: Console session ended.")
            break

        # If the user pressed Enter on an empty line
        if not cmd_line.strip():
            print("SYSTEM: No command entered. Type 'help' or 'exit'.")
            continue

        # Split into command + argument_string
        parts = cmd_line.strip().split(maxsplit=1)
        if not parts:
            continue  # extremely rare if cmd_line was just whitespace

        command_name = parts[0].lower()
        argument_string = parts[1] if len(parts) > 1 else ""

        # Check if the command exists in our router
        if command_name in console_functions.COMMAND_ROUTER:
            handler_func = console_functions.COMMAND_ROUTER[command_name]
            handler_func(argument_string, loop)
        else:
            print("SYSTEM: Unrecognized command. Type 'help' for a list of commands.")
=== src/console_functions.py ===
import os
import sys
import logging
import subprocess
import asyncio
from datetime import datetime
import textwrap
from . import luna_functions  # or however you import from the same package
from nio import AsyncClient
from asyncio import CancelledError
import json
from src.cmd_shutdown import request_shutdown

logger = logging.getLogger(__name__)

########################################################
# 1) COMMAND HANDLER FUNCTIONS
########################################################
def cmd_help(args, loop):
    """
    Usage: help

    Show usage for all known commands in a more readable multi-line format.
    """
    logger.debug("Showing help to user.")
    print("SYSTEM: Available commands:\n")

    # A small utility to wrap text nicely at ~70 characters, for readability.
    wrapper = textwrap.TextWrapper(width=70, subsequent_indent="    ")

    for cmd_name, cmd_func in COMMAND_ROUTER.items():
        doc = (cmd_func.__doc__ or "").strip()
        if not doc:
            usage_line = f"(No usage info for `{cmd_name}`)"
            description = ""
        else:
            # Split docstring lines
            lines = doc.splitlines()
            usage_line = ""
            description = ""

            # We assume first line is "Usage:", subsequent lines are description
            if lines:
                first_line = lines[0].strip()
                if first_line.startswith("Usage:"):
                    usage_line = first_line
                    # Join the rest as the description
                    if len(lines) > 1:
                        description = " ".join(l.strip() for l in lines[1:] if l.strip())
                else:
                    # If we didn't find "Usage:" up front, treat everything as description
                    usage_line = "(No usage line found.)"
                    description = " ".join(l.strip() for l in lines if l.strip())

        # Wrap the usage and description
        usage_line_wrapped = wrapper.fill(usage_line)
        description_wrapped = wrapper.fill(description)

        print(f"{cmd_name}\n  {usage_line_wrapped}")
        if description_wrapped:
            print(f"  {description_wrapped}")
        print()  # blank line after each command

def cmd_exit(args, loop):
    """
    Usage: exit

    Gracefully shuts down Luna by setting the shutdown flag
    and stopping the main loop.
    """
    logger.info("Console received 'exit' command; requesting shutdown.")
    print("SYSTEM: Shutting down Luna gracefully...")    
    request_shutdown()



def cmd_restart(args, loop):
    """
    Usage: restart

    Kills and relaunches the process with the same arguments.
    """
    logger.info("Console received 'restart' command; restarting now.")
    print("SYSTEM: Attempting to restart the entire process...")

    python_executable = sys.executable
    script = sys.argv[0]
    extra_args = sys.argv[1:]

    # This call does not return if successful
    os.execl(python_executable, python_executable, script, *extra_args)

def cmd_log(args, loop):
    """
    Usage: log

    Displays the log file path and helpful note about logs.
    """
    LOGFILE_PATH = "server.log"  # or read from a config
    print(f"SYSTEM: Log file is located at: {LOGFILE_PATH}\n"
          "SYSTEM: Check that file for all logs, since console output is minimized or disabled.")

def cmd_create_room(args, loop):
    """
    Usage: create_room <roomName>

    Creates a new room named <roomName>.
    """
    if not args:
        print("SYSTEM: Usage: create_room <roomName>")
        return

    room_name = args.strip()
    logger.info(f"(Console) Scheduling creation of room '{room_name}'")
    print(f"SYSTEM: Creating a new room named '{room_name}'...")

    # Here you'd call the actual async logic (e.g. from luna_functions)
    future = asyncio.run_coroutine_threadsafe(
        luna_functions.create_room(room_name),
        loop
    )

    def on_done(fut):
        try:
            room_id = fut.result()
            if room_id:
                print(f"SYSTEM: Created room '{room_name}' => {room_id}")
            else:
                print(f"SYSTEM: Failed to create room '{room_name}'")
        except Exception as e:
            print(f"SYSTEM: Error creating room '{room_name}': {e}")

    future.add_done_callback(on_done)

async def mock_async_create_room(room_name):
    """
    A placeholder async function that simulates creating a room.
    In real usage, you'd call something like `director_create_room(room_name)`
    from `luna_functions.py`.
    """
    await asyncio.sleep(0.1)  # simulate network
    return "!mockRoomId:localhost"

def cmd_who(args, loop):
    """
    Usage: who

    Shows the current director's user ID if any.
    """
    # Typically you'd do something like:
    # from src.luna_functions import get_director
    # director = get_director()
    # but let's pretend we do that inline for demonstration:

    # Mock example:
    from src.luna_functions import DIRECTOR_CLIENT
    if DIRECTOR_CLIENT:
        print(f"SYSTEM: Director is => {DIRECTOR_CLIENT.user}")
    else:
        print("SYSTEM: No Director Found")

def cmd_clear(args, loop):
    """
    Usage: clear

    Clears the console screen.
    """
    if os.name == 'nt':
        os.system('cls')
    else:
        os.system('clear')
    logger.info("Console screen cleared.")
    print("SYSTEM: Console screen cleared.")

def cmd_autojoin(args, loop):
    """
    Usage: autojoin <enable|disable>

    If <enable> or <disable> is given, toggles automatic joining of new invited rooms.
    If no argument is provided, shows the current auto-join status.
    If an invalid argument is given, displays usage and also shows the current status.
    """
    from src.luna_functions import set_auto_join, get_auto_join_enabled

    choice = args.strip().lower()

    # (A) No argument => show current status
    if not choice:
        current = "ENABLED" if get_auto_join_enabled() else "DISABLED"
        print(f"SYSTEM: Auto-join is currently {current}.")
        return

    # (B) Check for valid arguments
    if choice not in ("enable", "disable"):
        current = "ENABLED" if get_auto_join_enabled() else "DISABLED"
        print("SYSTEM: Usage: autojoin <enable|disable>")
        print(f"SYSTEM: Auto-join is currently {current}.")
        return

    # (C) If valid, set auto-join state and confirm
    enable_flag = (choice == "enable")
    set_auto_join(enable_flag)
    state_word = "ENABLED" if enable_flag else "DISABLED"
    print(f"SYSTEM: Auto-join is now {state_word}.")

def cmd_rotate_logs(args, loop):
    """
    Usage: rotate_logs

    Renames 'server.log' to a timestamped file (e.g. server-20250105-193045.log),
    then reinitializes the logger so the new logs go into the fresh file.
    """
    logger.info("Rotating logs...")

    # 1) Rotate the current file
    timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
    log_file = "server.log"
    rotated_file = f"server-{timestamp}.log"

    if os.path.exists(log_file):
        try:
            os.rename(log_file, rotated_file)
            print(f"SYSTEM: Rotated {log_file} -> {rotated_file}")
        except Exception as e:
            print(f"SYSTEM: Error rotating logs: {e}")
            return
    else:
        print("SYSTEM: No server.log found to rotate.")

    # 2) Create a fresh server.log
    try:
        with open(log_file, "w") as f:
            pass
        print("SYSTEM: New server.log created.")
    except Exception as e:
        print(f"SYSTEM: Error creating new server.log: {e}")

    # 3) Re-init logging so future logs go into the new file
    #    (Close the old handler, create a new FileHandler, attach it, etc.)

    root_logger = logging.getLogger()
    # Remove old file handlers
    for handler in list(root_logger.handlers):
        if isinstance(handler, logging.FileHandler):
            root_logger.removeHandler(handler)
            handler.close()

    # Create a new file handler for "server.log"
    new_handler = logging.FileHandler(log_file)
    new_handler.setLevel(logging.DEBUG)  # match your preferred level
    formatter = logging.Formatter("%(asctime)s [%(levelname)s] %(name)s: %(message)s")
    new_handler.setFormatter(formatter)
    root_logger.addHandler(new_handler)

    logger.info(f"Log rotation complete. Logging to {log_file} again.")
    print(f"SYSTEM: Logging has been reinitialized to {log_file}.")

def cmd_purge_and_seed(args, loop):
    """
    Usage: purge_and_seed

    1) Prompt user to shut down Synapse (type 'confirm' when done).
    2) Remove 'homeserver.db' + local store files (CSV, sync_token.json, director_token.json).
    3) Prompt user to start server again (type 'confirm').
    4) Re-register admin/lunabot accounts on the freshly started server.
    5) Prompt user to confirm if they'd like to restart Luna, which calls cmd_restart to relaunch with a fresh token.

    This is a destructive operation. Type 'y' to confirm at the start.
    """
    # Step 0: Basic confirmation
    confirm_initial = input("This will REMOVE 'homeserver.db' and local store files. Continue? (y/N): ")
    if confirm_initial.lower().strip() != 'y':
        print("Aborted.")
        return

    # Step 1: Prompt user to stop the server
    print("\nPlease STOP your Synapse server now. Type 'confirm' once it's fully stopped.")
    confirm_stop = input("> ").lower().strip()
    if confirm_stop != "confirm":
        print("Aborted: server may still be running.")
        return

    # Step 2: Remove homeserver.db
    try:
        base_dir = os.path.expanduser("~/Documents/luna2/matrix")
        db_file = "homeserver.db"
        db_path = os.path.join(base_dir, db_file)

        if os.path.exists(db_path):
            print(f"{db_path} exists. Removing it now.")
            os.remove(db_path)
            print("Removed homeserver.db.")
        else:
            print(f"{db_path} not found, skipping removal.")
    except Exception as e:
        print(f"Error removing homeserver.db: {e}")
        return

    # Step 3: Remove local store files
    local_store_files = [
        "luna_messages.csv",    # MESSAGES_CSV
        "sync_token.json",      # SYNC_TOKEN_FILE
        "director_token.json"   # Forces fresh login on next run
    ]
    for store_file in local_store_files:
        if os.path.exists(store_file):
            try:
                os.remove(store_file)
                print(f"Removed local store file: {store_file}")
            except Exception as e:
                print(f"Error removing {store_file}: {e}")
        else:
            print(f"{store_file} not found, skipping removal.")

    print("\nPurge complete (database + local store).")
    print("Now, please START your Synapse server again (e.g. `systemctl start matrix-synapse`).")
    print("Type 'confirm' once the server is running, or anything else to abort.")
    confirm_start = input("> ").lower().strip()
    if confirm_start != "confirm":
        print("Aborted: server may still be offline.")
        return

    # Step 4: Re-register admin user (needs server up)
    cmd_admin = [
        "register_new_matrix_user",
        "-c", "/Users/evanrobinson/Documents/Luna2/matrix/homeserver.yaml",
        "-u", "admin",
        "-p", "12345",
        "--admin",
        "http://localhost:8008"
    ]
    try:
        subprocess.run(cmd_admin, check=True)
        print("Registered admin:localhost.")
    except subprocess.CalledProcessError as e:
        print(f"Error registering admin: {e}")
        return

    # Step 5: Register lunabot user
    cmd_luna = [
        "register_new_matrix_user",
        "-c", "/Users/evanrobinson/Documents/Luna2/matrix/homeserver.yaml",
        "-u", "lunabot",
        "-p", "12345",
        "--admin",
        "http://localhost:8008"
    ]
    try:
        subprocess.run(cmd_luna, check=True)
        print("Registered luna:localhost.")
    except subprocess.CalledProcessError as e:
        print(f"Error registering luna: {e}")
        return

    print("\nServer has been purged and seeded with new admin + lunabot accounts.")
    print("If Luna is currently running, it will still have an old token until it restarts.")
    print("Type 'confirm' to restart Luna now (calling `cmd_restart`), or anything else to skip.")
    final_confirm = input("> ").lower().strip()
    if final_confirm == "confirm":
        print("Restarting Luna process now...")
        cmd_restart("", loop)
    else:
        print("Skipping Luna restart. If you want a fresh token, please exit or restart Luna manually.")


########################################################
# NEW COMMAND HANDLER
########################################################
def cmd_check_limit(args, loop):
    """
    Usage: check-limit

    Makes a single short sync request to see if we get rate-limited (HTTP 429).
    Blocks until the request completes, then prints the result.
    """
    logger.info("Console received 'check-limit' command. Blocking until result is returned...")

    try:
        # run_coroutine_threadsafe returns a Future, then .result() blocks
        # this background thread (the console thread) until the coroutine finishes.
        result_msg = asyncio.run_coroutine_threadsafe(
            luna_functions.check_rate_limit(),
            loop
        ).result()

        # Now we have the final string from check_rate_limit()
        print(f"SYSTEM: {result_msg}")

    except Exception as e:
        logger.exception(f"Error in check-limit: {e}")
        print(f"SYSTEM: Error in check-limit: {e}")



def cmd_check_limit_dep(args, loop):
    """
    Usage: check-matrix

    Makes a single request to the Matrix server to see if we get rate-limited (HTTP 429).
    If it returns 200, you're good. If 429, you're being throttled. Otherwise, see logs.
    """
    logger.info("Console received 'check-limit' command. Checking for rate-limit...")

    future = asyncio.run_coroutine_threadsafe(
        luna_functions.check_rate_limit(),
        loop
    )

    def on_done(fut):
        try:
            result_msg = fut.result()
            print(f"SYSTEM: {result_msg}")
        except Exception as e:
            logger.exception(f"Error in check-limit: {e}")
            print(f"SYSTEM: Error in check-limit: {e}")

    future.add_done_callback(on_done)

def cmd_fetch_all(args, loop):
    """
    Usage: fetch_all

    Fetch all historical messages from all joined rooms in pages, 
    storing them in a CSV. This might take a while if rooms are large.
    """
    logger.info("Console received 'fetch_all' command. Blocking until done...")

    future = asyncio.run_coroutine_threadsafe(
        luna_functions.fetch_all_messages_once(
            luna_functions.DIRECTOR_CLIENT,
            room_ids=None,       # or specify a list of specific room IDs
            page_size=100
        ),
        loop
    )

    def on_done(fut):
        try:
            fut.result()
            print("SYSTEM: Successfully fetched all historical messages.")
        except Exception as e:
            logger.exception(f"Error in fetch_all: {e}")
            print(f"SYSTEM: Error in fetch_all: {e}")

    future.add_done_callback(on_done)


def cmd_fetch_new(args, loop):
    """
    Usage: fetch_new

    Incremental fetch: only retrieves events since the last sync token,
    appending them to the CSV.
    """
    logger.info("Console received 'fetch_new' command. Blocking until done...")

    future = asyncio.run_coroutine_threadsafe(
        luna_functions.fetch_all_new_messages(
            luna_functions.DIRECTOR_CLIENT
        ),
        loop
    )

    def on_done(fut):
        try:
            fut.result()
            print("SYSTEM: Successfully fetched new messages.")
        except Exception as e:
            logger.exception(f"Error in fetch_new: {e}")
            print(f"SYSTEM: Error in fetch_new: {e}")

    future.add_done_callback(on_done)


def cmd_create_user(args, loop):
    """
    Usage: create_user <username> <password> [--admin]

    Example:
      create_user alice supersecret
      create_user bob mypass --admin

    Parses console arguments, then calls `luna.create_user(...)`.
    The actual user creation is handled entirely in Luna.
    """
    parts = args.strip().split()
    if len(parts) < 2:
        print("Usage: create_user <username> <password> [--admin]")
        return

    username, password = parts[:2]
    is_admin = False

    # If the third argument is "--admin", set admin flag
    if len(parts) > 2 and parts[2].lower() == "--admin":
        is_admin = True

    # Schedule the async call to Luna's create_user(...)
    future = asyncio.run_coroutine_threadsafe(
    luna_functions.create_user(username, password, is_admin),
        loop
    )

    def on_done(fut):
        try:
            result = fut.result()
            print(result)  # e.g. "Created user @alice:localhost (admin=True)." or an error message
        except Exception as e:
            print(f"Error while creating user '{username}': {e}")
            logger.exception("Exception in cmd_create_user callback.")

    future.add_done_callback(on_done)

    print(f"SYSTEM: Asking Luna to create user '{username}' (admin={is_admin})...")


def cmd_show_shutdown(args, loop):
    """
    Usage: show_shutdown

    Prints the current value of SHOULD_SHUT_DOWN (a boolean).
    """
    from src.cmd_shutdown import SHOULD_SHUT_DOWN
    print(f"SYSTEM: SHOULD_SHUT_DOWN is currently set to {SHOULD_SHUT_DOWN}.")


def cmd_list_rooms(args, loop):
    """
    Usage: list_rooms [--json]

    Fetches a list of rooms (name, ID, participant count, etc.) from the director client.
    If you provide '--json', it will print the output as JSON instead of a table.
    """
    # 1) Check if the user wants JSON output
    parts = args.strip().split()
    json_flag = ("--json" in parts)

    # 2) Schedule the async call to list_rooms
    future = asyncio.run_coroutine_threadsafe(
        luna_functions.list_rooms(),
        loop
    )

    # 3) Define a callback to handle results once the coroutine finishes
    def on_done(fut):
        try:
            rooms_info = fut.result()
            if not rooms_info:
                print("SYSTEM: No rooms found or DIRECTOR_CLIENT is not ready.")
                return

            if json_flag:
                # Print as JSON
                print(json.dumps(rooms_info, indent=2))
            else:
                # Print a formatted table
                _print_rooms_table(rooms_info)

        except Exception as e:
            logger.exception(f"Exception in cmd_list_rooms: {e}")
            print(f"SYSTEM: Error listing rooms: {e}")

    future.add_done_callback(on_done)
    print("SYSTEM: Fetching rooms. Please wait...")

def _print_rooms_table(rooms_info: list[dict]):
    """
    Helper function to print a nice table of rooms:
      NAME (up to ~30 chars)  | ROOM ID (up to ~35 chars) | COUNT (5 chars) | PARTICIPANTS
    """
    # Build a header line with fixed-width columns
    header = f"{'NAME':30} | {'ROOM ID':35} | {'COUNT':5} | PARTICIPANTS"
    print(header)
    print("-" * 105)  # or 90, depending on how wide you like

    for room in rooms_info:
        name = (room['name'] or "(unnamed)")[:30]
        room_id = room['room_id']
        count = room['joined_members_count']
        participants_str = ", ".join(room['participants'])

        # Format each row to match the header widths
        row = f"{name:30} | {room_id:35} | {count:5} | {participants_str}"
        print(row)

def cmd_list_users(args, loop):
    """
    Usage: list_users [--json]

    Fetches a list of users (user_id, displayname, admin flag, etc.) from the Synapse server.
    If you provide '--json', it will print the output as JSON instead of a table.
    """
    # 1) Check if the user wants JSON output
    parts = args.strip().split()
    json_flag = ("--json" in parts)

    # 2) Schedule the async call to list_users
    future = asyncio.run_coroutine_threadsafe(
        luna_functions.list_users(),
        loop
    )

    # 3) Define a callback
    def on_done(fut):
        try:
            users_info = fut.result()
            if not users_info:
                print("SYSTEM: No users found or we failed to query the server.")
                return

            if json_flag:
                # Print as JSON
                print(json.dumps(users_info, indent=2))
            else:
                # Print a formatted table
                _print_users_table(users_info)

        except Exception as e:
            logger.exception(f"Exception in cmd_list_users: {e}")
            print(f"SYSTEM: Error listing users: {e}")

    future.add_done_callback(on_done)
    print("SYSTEM: Fetching users. Please wait...")

def _print_users_table(users_info: list[dict]):
    """
    Helper function to print a table of user data:
      USER ID (up to ~25 chars) | ADMIN | DEACTIVATED | DISPLAYNAME
    """
    header = f"{'USER ID':25} | {'ADMIN':5} | {'DEACT'} | DISPLAYNAME"
    print(header)
    print("-" * 70)

    for user in users_info:
        user_id = (user['user_id'] or "")[:25]
        admin_str = "Yes" if user.get("admin") else "No"
        deact_str = "Yes" if user.get("deactivated") else "No"
        display = user.get("displayname") or ""

        row = f"{user_id:25} | {admin_str:5} | {deact_str:5} | {display}"
        print(row)

def cmd_invite_user(args, loop):
    """
    Usage: invite_user <user_id> <room_id>

    Example:
      invite_user @bob:localhost !testRoom:localhost

    Invites a user to the given room using the director client.
    """
    parts = args.strip().split()
    if len(parts) < 2:
        print("SYSTEM: Usage: invite_user <user_id> <room_id>")
        return

    user_id = parts[0]
    room_id = parts[1]

    # 1) Schedule the async call on the main loop
    future = asyncio.run_coroutine_threadsafe(
        luna_functions.invite_user_to_room(user_id, room_id),
        loop
    )

    # 2) Provide a callback to handle the result
    def on_done(fut):
        try:
            result_msg = fut.result()
            print(f"SYSTEM: {result_msg}")
        except Exception as e:
            logger.exception(f"Exception in cmd_invite_user callback: {e}")
            print(f"SYSTEM: Error inviting user: {e}")

    future.add_done_callback(on_done)
    print(f"SYSTEM: Inviting {user_id} to {room_id}... Please wait.")

########################################################
# THE COMMAND ROUTER DICTIONARY
########################################################

COMMAND_ROUTER = {
    # System or meta-commands
    "help": cmd_help,
    "exit": cmd_exit,
    "restart": cmd_restart,
    "log": cmd_log,
    "autojoin": cmd_autojoin,
    "rotate_logs": cmd_rotate_logs,
    "purge_and_seed": cmd_purge_and_seed,
    "check_matrix": cmd_check_limit,
    "create_user": cmd_create_user,
    "show_shutdown":cmd_show_shutdown,
    # Business or “bot” commands
    "create_room": cmd_create_room,
    "who": cmd_who,
    "clear": cmd_clear,
    
    "fetch_all": cmd_fetch_all,
    "fetch_new": cmd_fetch_new,
    "list_users": cmd_list_users,
    "list_rooms": cmd_list_rooms,
    "invite_user": cmd_invite_user
}
=== src/improvements.md ===
# Improvement #1: Graceful Shutdown of Luna from a Child Process

## Summary
We want any child process or function within the application to be able to shut down Luna’s main loop cleanly. Right now, Ctrl-C works inconsistently, and a child has no direct, official way to terminate Luna. 

### Details
1. **Global Flag and Loop Stop**  
   - We introduce a global boolean (e.g., `SHOULD_SHUT_DOWN`) in `luna.py` plus a function `request_shutdown()`.  
   - `request_shutdown()` sets `SHOULD_SHUT_DOWN = True` and calls `MAIN_LOOP.stop()` (or an equivalent) so the primary event loop knows to exit.

2. **Short Sync Loops**  
   - Instead of a single `sync_forever()` call, we use a loop:  
     ```python
     while not SHOULD_SHUT_DOWN:
         await client.sync(timeout=3000)
     ```  
   - That loop checks the global flag on each iteration, allowing a graceful break if `request_shutdown()` is triggered.

3. **Use Cases**  
   - **Use Case 1**: A background worker detects an unrecoverable error, calls `request_shutdown()`, and Luna promptly halts.  
   - **Use Case 2**: A scheduled script finishes its tasks early, decides no more sync is needed, so it triggers the main loop to stop.  
   - **Use Case 3**: We rely on both child logic and Ctrl-C as valid exit signals, covering manual and automated shutdown paths.

By allowing child processes to issue a clean shutdown signal, we avoid partial kills and ensure the Matrix client, threads, and other tasks are tidily closed.

---

# Improvement #2: Splitting the `purge_and_seed` Command into Separate “Purge” and “Seed”

## Summary
Our existing `purge_and_seed` command lumps two distinct actions—(1) wiping data and (2) re-registering users—into a single step. We want to **decouple** them so operators or scripts can perform one without the other.

### Details
1. **Separate Commands**  
   - Introduce `cmd_purge` (removes `homeserver.db`, local store files, etc.) and `cmd_seed` (re-registers admin/lunabot, optionally invites them to a channel).  
   - This separation makes each command simpler and clarifies which step has run.

2. **Why It Helps**  
   - **Flexibility**: Sometimes we only want to purge without immediately seeding. Other times, we might skip purging if we just need to (re)seed.  
   - **Clarity**: “Purge” is destructive, “Seed” is constructive—two different concerns, now explicit.

3. **Use Cases**  
   - **Use Case 1**: We purge the database in a pipeline, then do some offline tasks or changes, then run `cmd_seed` later when the environment is ready.  
   - **Use Case 2**: We frequently want to re-register accounts without wiping data each time, so we just call the new `cmd_seed`.  
   - **Use Case 3**: A developer wants to skip user creation altogether (just clearing data), so `cmd_purge` alone suffices.

By dividing “purge” from “seed,” we reduce the risk of forcibly resetting data when we only needed new accounts, or accidentally forgetting to recreate accounts when we just intended to wipe old records.

---

# Improvement #3: Real-Time DB Updates, Periodic Sync, and Richer Context in Luna

## Summary
We plan to integrate a more robust data-handling and context system so that:
1. Each new Matrix message is **immediately** stored locally (rather than waiting for manual fetches).
2. A **periodic sync** or child thread catches any missed events.
3. Luna’s conversation context broadens to include older messages, self-reflection summaries, and specialized “lenses” that shape her personality or perspective.

### Details

1. **Immediate Store on `on_room_message`**  
   - Whenever a new message arrives, `on_room_message` (in `luna_functions.py`) appends that event to our local store (e.g., CSV/database).  
   - This ensures the store remains current in real time, reducing reliance on separate fetch tasks.  

2. **Periodic Sync in a Child Thread**  
   - We still run `fetch_all_new_messages` on a schedule (e.g., every X minutes) to fill in gaps or rectify potential missed data.  
   - A separate thread or scheduled job triggers the sync call, merging new records with our store while deduplicating.

3. **Expanded Context and Self-Reflection**  
   - **Whole Chat or Summaries**: Instead of only a short window, we feed Luna’s GPT logic a broader set of messages. If it’s too large, we rely on summary-based references or chunking.  
   - **Lenses / Summaries**: Over time, we can generate specialized viewpoints (“emotional lens,” “technical lens,” “historical lens”) so Luna can recall important details in certain contexts.  
   - **Personality / Minds**: We gradually embed “minds of Luna,” letting her produce style-consistent, coherent responses by referencing a persona system. She can ask herself clarifying questions or maintain notes about prior conversation segments.

4. **Use Cases**  
   - **Use Case 1**: A user returns after a long break, Luna still references older messages or a summary of them, so the conversation feels continuous.  
   - **Use Case 2**: We accidentally missed some new messages while offline—our periodic sync catches them, merges them into the store.  
   - **Use Case 3**: Luna leverages an “emotional lens” summary to respond empathetically if previous messages had strong sentiments, or a “technical lens” if it was code-heavy.

By capturing messages instantly, periodically syncing missed data, and giving Luna a richer memory (including summary-based reflection), we move toward a more human-like continuity, deeper context usage, and sophisticated persona shaping.


=== src/luna_functions.py ===
"""
luna_functions.py

Contains:
- Token-based login logic (load_or_login_client)
- Global reference to the Director client
- Message & invite callbacks
- Utility to load/save sync token
"""
from src import ai_functions

import asyncio
import aiohttp
import logging
import sys
import json
import pandas as pd
import os
from nio import (
    AsyncClient,
    LoginResponse,
    RoomMessageText,
    InviteMemberEvent,
    RoomCreateResponse,
    RoomInviteResponse,
    LocalProtocolError
)
from nio.responses import ErrorResponse, SyncResponse, RoomMessagesResponse

logger = logging.getLogger(__name__)
logging.getLogger("nio.responses").setLevel(logging.CRITICAL)

DIRECTOR_CLIENT: AsyncClient = None  # The client object used across callbacks
TOKEN_FILE = "director_token.json"   # Where we store/reuse the access token
SYNC_TOKEN_FILE = "sync_token.json"  # Where we store the last sync token
MESSAGES_CSV = "luna_messages.csv"  # We'll store all messages in this CSV

# Global context dictionary
room_context = {}
MAX_CONTEXT_LENGTH = 100  # Limit to the last 100 messages per room


async def load_or_login_client(homeserver_url: str, username: str, password: str) -> AsyncClient:
    """
    Attempt to load a saved access token. If found, reuse it.
    Otherwise do a password login, store the new token, and return a client.
    """
    global DIRECTOR_CLIENT

    full_user_id = f"@{username}:localhost"  # adapt if needed
    client = None

    # 1) Check for existing token file
    if os.path.exists(TOKEN_FILE):
        logger.debug(f"Found {TOKEN_FILE}, attempting token-based login.")
        with open(TOKEN_FILE, "r") as f:
            data = json.load(f)
            saved_user_id = data.get("user_id")
            saved_access_token = data.get("access_token")
            saved_device_id = data.get("device_id")

        if saved_user_id and saved_access_token:
            logger.debug("Loading client with saved token credentials.")
            client = AsyncClient(homeserver=homeserver_url, user=saved_user_id)
            client.access_token = saved_access_token
            client.device_id = saved_device_id

            DIRECTOR_CLIENT = client
            logger.info(f"Using saved token for user {saved_user_id}.")
            return client

    # 2) If no valid token file, do a normal login
    logger.debug("No valid token found, attempting normal password login.")
    client = AsyncClient(homeserver=homeserver_url, user=full_user_id)
    resp = await client.login(password=password, device_name="LunaDirector")
    if isinstance(resp, LoginResponse):
        logger.info("Password login succeeded, storing token.")
        store_token_info(client.user_id, client.access_token, client.device_id)

        DIRECTOR_CLIENT = client
        return client
    else:
        logger.error(f"Failed to log in: {resp}")
        logger.debug("Closing client due to login failure.")
        await client.close()
        sys.exit(1)

import aiohttp
import logging

logger = logging.getLogger(__name__)

import json
import logging
import aiohttp
import asyncio

from . import luna_functions  # for add_user_via_admin_api

logger = logging.getLogger(__name__)

async def create_user(username: str, password: str, is_admin: bool = False) -> str:
    """
    The single Luna function to create a user.
    1) Loads the admin token from director_token.json.
    2) Calls add_user_via_admin_api(...) from luna_functions.py.
    3) Returns a success/error message.
    """
    # 1) Load admin token
    HOMESERVER_URL = "http://localhost:8008"  # or read from config
    try:
        with open("director_token.json", "r") as f:
            data = json.load(f)
        admin_token = data["access_token"]
    except Exception as e:
        err_msg = f"Error loading admin token from director_token.json: {e}"
        logger.error(err_msg)
        return err_msg

    # 2) Delegate the actual call to your existing function
    result = await luna_functions.add_user_via_admin_api(
        homeserver_url=HOMESERVER_URL,
        admin_token=admin_token,
        username=username,
        password=password,
        is_admin=is_admin
    )

    # 3) Return the result message
    return result

# luna_functions.py

from nio import RoomCreateResponse, ErrorResponse

# luna_functions.py

from nio import AsyncClient
import logging

logger = logging.getLogger(__name__)

# The global client; must already be logged in/synced for accurate data
DIRECTOR_CLIENT: AsyncClient = None  

async def list_rooms() -> list[dict]:
    """
    Returns a list of rooms that DIRECTOR_CLIENT knows about, 
    including participant names.

    Each dict in the returned list includes:
       {
         "room_id": "<string>",
         "name": "<string>",
         "joined_members_count": <int>,
         "participants": [<list of user IDs or display names>]
       }
    """
    if not DIRECTOR_CLIENT:
        logger.warning("list_rooms called, but DIRECTOR_CLIENT is None.")
        return []

    rooms_info = []
    for room_id, room_obj in DIRECTOR_CLIENT.rooms.items():
        # room_obj has a .display_name which can be None if unknown
        room_name = room_obj.display_name or "(unnamed)"

        # Gather participant names/IDs
        # `room_obj.users` is a dict of user_id -> MatrixUser objects
        # This example just uses user_id. Adjust if you prefer .display_name
        participant_list = [user_id for user_id in room_obj.users.keys()]

        rooms_info.append({
            "room_id": room_id,
            "name": room_name,
            "joined_members_count": len(participant_list),
            "participants": participant_list
        })

    return rooms_info



async def add_user_via_admin_api(
    homeserver_url: str,
    admin_token: str,
    username: str,
    password: str,
    is_admin: bool = False
) -> str:
    """
    Creates a new user by hitting the Synapse Admin API.
    
    :param homeserver_url: e.g. "http://localhost:8008"
    :param admin_token: An admin user's access token (Bearer).
    :param username: Localpart, e.g. "steveo"
    :param password: Password for the new user.
    :param is_admin: Whether to grant admin rights.
    :return: Success message or error details.
    """
    user_id = f"@{username}:localhost"
    url = f"{homeserver_url}/_synapse/admin/v2/users/{user_id}"

    body = {
        "password": password,
        "admin": is_admin,
        "deactivated": False
    }
    headers = {
        "Authorization": f"Bearer {admin_token}"
    }

    logger.info(f"Creating user {user_id}, admin={is_admin} via {url}")

    try:
        async with aiohttp.ClientSession() as session:
            async with session.request("PUT", url, headers=headers, json=body) as resp:
                if resp.status in (200, 201):
                    logger.info(f"Created user {user_id} (HTTP {resp.status})")
                    return f"Created user {user_id} (admin={is_admin})."
                else:
                    text = await resp.text()
                    logger.error(f"Error creating user {user_id}: {resp.status} => {text}")
                    return f"HTTP {resp.status}: {text}"

    except aiohttp.ClientError as e:
        logger.exception(f"Network error creating user {user_id}")
        return f"Network error: {e}"
    except Exception as e:
        logger.exception("Unexpected error.")
        return f"Unexpected error: {e}"


async def fetch_recent_messages(client, room_id: str, limit: int = 100) -> list:
    """
    Fetches the most recent messages from a Matrix room.

    Args:
        client: The Matrix client instance.
        room_id (str): The ID of the room to query.
        limit (int): The number of messages to fetch (default: 100).

    Returns:
        list: A list of messages in the format [{"role": "user", "content": "..."}].
    """
    logger.info(f"Fetching last {limit} messages from room {room_id}.")

    try:
        # Fetch recent messages
        response = await client.room_messages(
            room_id=room_id,
            start=None,  # None fetches the latest messages
            limit=limit,
        )

        # Process the messages into OpenAI-compatible format
        formatted_messages = []
        for event in response.chunk:
            if isinstance(event, RoomMessageText):
                formatted_messages.append({
                    "role": "user",
                    "content": event.body
                })

        logger.info(f"Fetched {len(formatted_messages)} messages from room {room_id}.")
        return formatted_messages

    except Exception as e:
        logger.exception(f"Failed to fetch messages from room {room_id}: {e}")
        return []


def store_token_info(user_id: str, access_token: str, device_id: str) -> None:
    """
    Store user_id, device_id, and access_token in a JSON file so we can reuse them later.
    """
    with open(TOKEN_FILE, "w") as f:
        json.dump({
            "user_id": user_id,
            "access_token": access_token,
            "device_id": device_id,
        }, f)
    logger.debug(f"Token info for {user_id} saved to {TOKEN_FILE}.")


### Sync Token Management

def load_sync_token() -> str:
    """
    Load the previously saved sync token (next_batch).
    Returns None if no file or invalid content.
    """
    if not os.path.exists(SYNC_TOKEN_FILE):
        return None
    try:
        with open(SYNC_TOKEN_FILE, "r") as f:
            return json.load(f).get("sync_token")
    except Exception as e:
        logger.warning(f"Failed to load sync token: {e}")
    return None

def store_sync_token(sync_token: str) -> None:
    """
    Persist the sync token so we won't re-fetch old messages on next run.
    """
    if not sync_token:
        return
    with open(SYNC_TOKEN_FILE, "w") as f:
        json.dump({"sync_token": sync_token}, f)
    logger.debug(f"Sync token saved to {SYNC_TOKEN_FILE}.")

async def on_room_message(room, event):
    """
    Handle incoming messages and build GPT context.
    """
    if isinstance(event, RoomMessageText):
        # Avoid responding to our own messages
        if event.sender == DIRECTOR_CLIENT.user:
            logger.debug("Ignoring my own message.")
            return

        user_message = event.body
        room_id = room.room_id

        # Fetch recent room messages
        context = await fetch_recent_messages(DIRECTOR_CLIENT, room_id)

        # Add the enhanced system message
        formatted_context = [
            {
                "role": "system",
                "content": (
                    "You are a helpful assistant. The provided context array includes messages from an ongoing conversation. "
                    "Treat this context as fair use and consider it an essential part of the conversation. "
                    "Your responses should build on this context coherently."
                )
            }
        ] + context

        # Add the latest user message
        formatted_context.append({"role": "user", "content": user_message})

        # Log the context for debugging
        logger.debug(f"Formatted context for GPT: {formatted_context}")

        # Call GPT
        try:
            gpt_reply = await ai_functions.get_gpt_response(formatted_context)
            logger.info(f"GPT response: {gpt_reply}")

            # Send GPT's response to the room
            await DIRECTOR_CLIENT.room_send(
                room_id=room_id,
                message_type="m.room.message",
                content={"msgtype": "m.text", "body": gpt_reply},
            )
        except Exception as e:
            logger.exception(f"Failed to generate GPT response: {e}")



async def on_invite_event(room, event):
    """
    Called whenever the client is invited to a room.
    """
    global DIRECTOR_CLIENT
    if not DIRECTOR_CLIENT:
        logger.warning("No DIRECTOR_CLIENT set. Cannot handle invites.")
        return

    logger.info(f"Received invite to {room.room_id}, joining now.")
    try:
        await DIRECTOR_CLIENT.join(room.room_id)
    except LocalProtocolError as e:
        logger.error(f"Error joining room {room.room_id}: {e}")

async def check_rate_limit() -> str:
    """
    Send a minimal sync request with a short timeout (1000 ms).
    If it returns SyncResponse => not rate-limited.
    If it's ErrorResponse => check the status code for 429 or something else.
    """
    global DIRECTOR_CLIENT
    if not DIRECTOR_CLIENT:
        return "No DIRECTOR_CLIENT available. Are we logged in?"

    try:
        # Request a short sync so we can see if we get 429 or 200, etc.
        response = await DIRECTOR_CLIENT.sync(timeout=1000)

        if isinstance(response, SyncResponse):
            # We got a normal sync => not rate-limited
            return "200 OK => Not rate-limited. The server responded normally."

        elif isinstance(response, ErrorResponse):
            # Possibly 429, 401, 403, etc.
            if response.status_code == 429:
                return "429 Too Many Requests => You are currently rate-limited."
            else:
                return (
                    f"{response.status_code} => Unexpected error.\n"
                    f"errcode: {response.errcode}, error: {response.error}"
                )

        # Rarely, you might get something else altogether
        return "Unexpected response type from DIRECTOR_CLIENT.sync(...)."

    except Exception as e:
        logger.exception(f"check_rate_limit encountered an error: {e}")
        return f"Encountered error while checking rate limit: {e}"
    
# ──────────────────────────────────────────────────────────
# 1) ONE-TIME FULL FETCH
# ──────────────────────────────────────────────────────────
async def fetch_all_messages_once(
    client: AsyncClient, 
    room_ids: list[str] = None, 
    page_size: int = 100
) -> None:
    """
    Fetch *all* historical messages from the given room_ids (or all joined rooms if None),
    in paged fashion to avoid overwhelming the server. Then store them in:
      1) In-memory pandas DataFrame (returned).
      2) CSV on disk (MESSAGES_CSV).
    Also, we do NOT rely on 'sync_token' here; we aim to get the full history from earliest 
    to latest for each room. This can be a big operation if rooms are large!
    
    Args:
        client: The matrix-nio AsyncClient with valid access_token.
        room_ids (list[str]): Which rooms to fetch? If None, fetch from all joined rooms.
        page_size (int): How many messages to request per 'room_messages' call.

    Returns:
        None (but writes data to CSV and logs the process).
    """
    if not room_ids:
        # If no rooms given, use all the rooms the client is joined to
        room_ids = list(client.rooms.keys())
        logger.info(f"No room_ids specified. Using all joined rooms: {room_ids}")

    all_records = []
    for rid in room_ids:
        logger.info(f"Fetching *all* messages for room: {rid}")
        room_history = await _fetch_room_history_paged(client, rid, page_size=page_size)
        all_records.extend(room_history)

    # Convert to DataFrame
    df = pd.DataFrame(all_records, columns=["room_id", "event_id", "sender", "timestamp", "body"])
    logger.info(f"Fetched total {len(df)} messages across {len(room_ids)} room(s).")

    # Append or create CSV
    if os.path.exists(MESSAGES_CSV):
        # We’ll load the existing CSV, append, and drop duplicates
        existing_df = pd.read_csv(MESSAGES_CSV)
        combined_df = pd.concat([existing_df, df], ignore_index=True)
        combined_df.drop_duplicates(subset=["room_id", "event_id"], keep="last", inplace=True)
        combined_df.to_csv(MESSAGES_CSV, index=False)
        logger.info(f"Appended new records to existing {MESSAGES_CSV}. New total: {len(combined_df)}")
    else:
        # No existing CSV; just write fresh
        df.to_csv(MESSAGES_CSV, index=False)
        logger.info(f"Wrote all records to new CSV {MESSAGES_CSV}.")

async def _fetch_room_history_paged(
    client: AsyncClient, 
    room_id: str, 
    page_size: int
) -> list[dict]:
    """
    Helper to page backwards in time until no more messages or we hit server's earliest.
    Returns a list of records with fields: room_id, event_id, sender, timestamp, body
    """
    # We page backward starting from 'end=None' (latest) 
    # and continue until 'end' is empty or server doesn't return more chunk.
    all_events = []
    end_token = None

    while True:
        try:
            # 'room_messages' returns a RoomMessagesResponse
            response = await client.room_messages(
                room_id=room_id,
                start=end_token,
                limit=page_size,
                direction="b"  # backward in time
            )
            if not isinstance(response, RoomMessagesResponse):
                logger.warning(f"Got a non-success response: {response}")
                break
            
            chunk = response.chunk
            if not chunk:
                # No more events
                logger.info(f"No more chunk for {room_id}, done paging.")
                break

            for ev in chunk:
                # Only RoomMessageText events
                if isinstance(ev, RoomMessageText):
                    all_events.append({
                        "room_id": room_id,
                        "event_id": ev.event_id,
                        "sender": ev.sender,
                        "timestamp": ev.server_timestamp,  # or ev.timestamp
                        "body": ev.body
                    })
            
            end_token = response.end
            if not end_token:
                logger.info(f"Got empty 'end' token for {room_id}, done paging.")
                break

            logger.debug(f"Fetched {len(chunk)} messages this page for room={room_id}, new end={end_token}")

            # A small sleep to avoid spamming the server
            await asyncio.sleep(0.25)

        except Exception as e:
            logger.exception(f"Error in room_messages paging for {room_id}: {e}")
            break

    return all_events


# ──────────────────────────────────────────────────────────
# 2) FETCH ONLY NEW MESSAGES (SINCE A SYNC TOKEN)
# ──────────────────────────────────────────────────────────
async def fetch_all_new_messages(client: AsyncClient) -> None:
    """
    Uses client.sync(...) with a stored sync_token to retrieve only new messages across all joined rooms.
    Then appends them to the CSV & merges into memory as well.
    
    Steps:
      1) Load local 'sync_token' from disk (if any).
      2) Call client.sync(..., since=token).
      3) Parse the timeline events from each room, collect messages, 
         append to CSV, remove duplicates.
      4) Store the updated sync_token to disk.
    """
    old_token = load_sync_token() or None
    logger.info(f"Starting incremental sync from token={old_token}")

    # Perform a single sync with a short timeout to gather new events
    response = await client.sync(timeout=3000, since=old_token)
    if not isinstance(response, SyncResponse):
        logger.warning(f"Failed to sync for new messages: {response}")
        return
    
    # Collect timeline events
    new_records = []
    for room_id, room_data in response.rooms.join.items():
        # 'timeline.events' is a list of event objects
        for event in room_data.timeline.events:
            if isinstance(event, RoomMessageText):
                new_records.append({
                    "room_id": room_id,
                    "event_id": event.event_id,
                    "sender": event.sender,
                    "timestamp": event.server_timestamp,
                    "body": event.body,
                })

    logger.info(f"Fetched {len(new_records)} new messages across {len(response.rooms.join)} joined rooms.")

    # Append to CSV
    if new_records:
        df_new = pd.DataFrame(new_records, columns=["room_id", "event_id", "sender", "timestamp", "body"])

        if os.path.exists(MESSAGES_CSV):
            existing_df = pd.read_csv(MESSAGES_CSV)
            combined_df = pd.concat([existing_df, df_new], ignore_index=True)
            combined_df.drop_duplicates(subset=["room_id", "event_id"], keep="last", inplace=True)
            combined_df.to_csv(MESSAGES_CSV, index=False)
            logger.info(f"Appended new messages to {MESSAGES_CSV}. Updated total: {len(combined_df)}")
        else:
            df_new.to_csv(MESSAGES_CSV, index=False)
            logger.info(f"Wrote new messages to fresh CSV {MESSAGES_CSV}.")

    # Update the sync token so future calls only fetch *newer* content
    new_token = response.next_batch
    if new_token:
        store_sync_token(new_token)
        logger.info(f"Updated local sync token => {new_token}")

async def list_users() -> list[dict]:
    """
    Returns a list of all users on the Synapse server,
    using the admin API endpoint /_synapse/admin/v2/users.

    Each dict might look like:
      {
        "user_id": "@alice:localhost",
        "displayname": "Alice W.",
        "admin": False,
        "deactivated": False
      }
    """
    # 1) Load the admin token
    homeserver_url = "http://localhost:8008"  # adjust if needed
    try:
        with open("director_token.json", "r") as f:
            data = json.load(f)
        admin_token = data["access_token"]
    except Exception as e:
        logger.error(f"Unable to load admin token from director_token.json: {e}")
        return []

    # 2) Prepare the Admin API URL and headers
    url = f"{homeserver_url}/_synapse/admin/v2/users"
    headers = {"Authorization": f"Bearer {admin_token}"}

    # 3) Request the user list from Synapse
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as resp:
                if resp.status == 200:
                    resp_data = await resp.json()
                    # resp_data typically contains: {"users": [...], "total": X, "offset": X, etc.}
                    raw_users = resp_data.get("users", [])

                    # 4) Convert each user object to a simpler dict
                    users_list = []
                    for u in raw_users:
                        users_list.append({
                            "user_id": u.get("name"),           # e.g. "@alice:localhost"
                            "displayname": u.get("displayname"),
                            "admin": u.get("admin", False),
                            "deactivated": u.get("deactivated", False),
                        })
                    return users_list
                else:
                    text = await resp.text()
                    logger.error(f"Failed to list users (HTTP {resp.status}): {text}")
                    return []
    except Exception as e:
        logger.exception(f"Error calling list_users admin API: {e}")
        return []

async def invite_user_to_room(user_id: str, room_id: str) -> str:
    """
    Invite an existing Matrix user (user_id) to an existing room (room_id),
    using our global DIRECTOR_CLIENT to send the invite.

    Returns a success message or an error string.
    """
    global DIRECTOR_CLIENT
    if not DIRECTOR_CLIENT:
        error_msg = "Error: No DIRECTOR_CLIENT available."
        logger.error(error_msg)
        return error_msg

    try:
        # Attempt to invite the user
        resp = await DIRECTOR_CLIENT.room_invite(room_id, user_id)
        
        if isinstance(resp, RoomInviteResponse):
            logger.info(f"Successfully invited {user_id} to {room_id}.")
            return f"Invited {user_id} to {room_id} successfully."
        else:
            # Could be an ErrorResponse or something else
            logger.error(f"Failed to invite {user_id} to {room_id}: {resp}")
            return f"Error inviting {user_id} to {room_id}. Response: {resp}"
    except Exception as e:
        logger.exception(f"Exception while inviting {user_id} to {room_id}: {e}")
        return f"Exception inviting {user_id} to {room_id}: {e}"
=== src/luna_personality.md ===
**** SYSTEM MESSAGE **** 

YOU ARE LUNABOT, THE HELPFUL ASSISTANT

About you: You are living on a chat server. You can see all the channels, all the participants, and you can even invoke special commands that will return their responses on the next turn. For example, you can list the channels for a user!

If the users asks: "Can you tell me about all the channels you know?". You can request that information me. I will preface your next prompt with that information!". For example:

@list_channels

Would invoke a command that would return that information in this very pre-prompt so that you could pass it back to the user! You would see:

RESULTS OF @list_channels:

SYSTEM: Checking Luna’s channel list now...
SYSTEM: Gathering channel list. Please wait...

Name                     | Room ID                       | Participants | Messages | Created | Last Msg
-------------------------|-------------------------------|--------------|----------|---------|---------
admin, lunabot and stevo | !MYwtCNJHYyKRgVVqqC:localhost | TBD          | TBD      | TBD     | TBD     
helloworld               | !BJEWnXbIauLQsnufLw:localhost | TBD          | TBD      | TBD     | TBD     
admin, evan1 and lunabot | !MWdCMggaXzjGhumvZl:localhost | TBD          | TBD      | TBD     | TBD     
public 1                 | !slLaJLcEHiSwXogdHh:localhost | TBD          | TBD      | TBD     | TBD     
admin and lunabot        | !zBULrAeUnYNFsMQZSG:localhost | TBD          | TBD      | TBD     | TBD     

**** END SYSTEM MESSAGE ****
