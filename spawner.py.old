import json
import asyncio
import logging
import shlex

# Suppose your GPT call is in ai_functions.py
from luna.ai_functions import get_gpt_response

logger = logging.getLogger(__name__)

def cmd_spawn_squad(args, loop):
    """
    The real logic for spawn_squad. 
    Called by console_functions.py or whichever file includes the “command router.”

    Usage: spawn_squad <numBots> "<theme or style>"

    Example:
      spawn_squad 3 "A jazzy trio of improvisational bots"
    """

    print("[DEBUG] Entering cmd_spawn_squad with args =", repr(args))
    logger.debug("cmd_spawn_squad => Received args=%r", args)

    # 1) Parse the arguments
    tokens = shlex.split(args.strip())
    print(f"[DEBUG] Parsed tokens => {tokens}")
    logger.debug("Parsed tokens => %s", tokens)

    if len(tokens) < 2:
        msg = "SYSTEM: Usage: spawn_squad <numBots> \"<theme>\""
        print(msg)
        logger.warning(msg)
        return

    try:
        count = int(tokens[0])
    except ValueError:
        msg = "SYSTEM: First arg must be an integer for the number of bots."
        print(msg)
        logger.warning(msg)
        return

    if count < 1 or count > 5:
        msg = "SYSTEM: Allowed range is 1 to 5 bots."
        print(msg)
        logger.warning(msg)
        return

    # Reconstruct the theme from all tokens after the first
    theme = " ".join(tokens[1:])
    print(f"[DEBUG] Using theme => '{theme}'")
    logger.debug("Spawn_squad => count=%d, theme=%r", count, theme)

    # 2) Build the GPT system instructions & user message
    system_instructions = (
        "You are an assistant that outputs ONLY valid JSON. "
        "No markdown, no code fences, no extra commentary. "
        "Generate an array of exactly {count} persona objects. "
        "Each object must have keys: localpart, displayname, system_prompt, password, traits. "
        "No other keys. "
        "The 'traits' key is a JSON object with arbitrary key/values. "
    ).format(count=count)

    user_message = (
        f"Please create {count} persona(s) for the theme: '{theme}'. "
        "Return ONLY valid JSON (an array, no outer text)."
    )

    print(f"[DEBUG] system_instructions => {system_instructions}")
    print(f"[DEBUG] user_message => {user_message}")
    logger.debug("system_instructions=%r", system_instructions)
    logger.debug("user_message=%r", user_message)

    async def do_spawn():
        print("[DEBUG] do_spawn => Starting GPT call ...")
        logger.debug("do_spawn => Starting GPT call (count=%d)", count)

        # 3) Actually call GPT to get JSON for the requested # of personas
        gpt_response = await get_gpt_response(
            messages=[
                {"role": "system", "content": system_instructions},
                {"role": "user",   "content": user_message}
            ],
            model="gpt-4",
            temperature=0.7,
            max_tokens=1000
        )
        print(f"[DEBUG] GPT responded with => {gpt_response[:200]!r}... (truncated)")
        logger.debug("GPT raw response => %r", gpt_response)

        # 4) Attempt to parse the JSON
        try:
            persona_array = json.loads(gpt_response)
            print(f"Created {persona_array}")
            logger.debug("Parsed persona_array => %s", persona_array)
        except json.JSONDecodeError as e:
            print(f"SYSTEM: GPT returned invalid JSON => {e}")
            logger.error("Invalid JSON from GPT => %s", gpt_response)
            return

        if not isinstance(persona_array, list):
            msg = "SYSTEM: GPT did not return a JSON list. Aborting."
            print(msg)
            logger.warning(msg)
            return

        if len(persona_array) != count:
            msg = ("SYSTEM: GPT returned a list of length "
                   f"{len(persona_array)}, expected {count}. Aborting.")
            print(msg)
            logger.warning(msg)
            return

        # 5) For each persona, call create_and_login_bot to spawn
        successes = 0
        for i, persona in enumerate(persona_array):
            print(f"[DEBUG] Spawning persona index {i} => {persona}")
            logger.debug("Persona[%d] => %s", i, persona)

            # Validate required keys
            missing_key = None
            for key in ["localpart", "displayname", "system_prompt", "password", "traits"]:
                if key not in persona:
                    missing_key = key
                    break

            if missing_key:
                msg = f"SYSTEM: Missing key '{missing_key}' in GPT object {i}. Skipping."
                print(msg)
                logger.warning(msg)
                continue

            # Build the Matrix user ID
            full_bot_id = f"@{persona['localpart']}:localhost"
            password = persona["password"]
            displayname = persona["displayname"]
            system_prompt = persona["system_prompt"]
            traits = persona["traits"]

            async def single_spawn():
                from luna.luna_command_extensions.create_and_login_bot import create_and_login_bot
                print(f"[DEBUG] -> single_spawn => about to create '{full_bot_id}'")
                logger.debug("single_spawn => Creating user_id=%r", full_bot_id)

                result_msg = await create_and_login_bot(
                    bot_id=full_bot_id,
                    password=password,
                    displayname=displayname,
                    system_prompt=system_prompt,
                    traits=traits,
                    creator_user_id="@lunabot:localhost",
                    is_admin=False
                )
                print(f"[DEBUG] -> single_spawn => returned result={result_msg!r}")
                logger.debug("single_spawn => result=%r", result_msg)
                return result_msg

            # BLOCKING approach: directly await single_spawn
            # so each persona is created in a strictly sequential manner
            spawn_result = await single_spawn()

            if "Successfully created" in spawn_result:
                successes += 1

            print(f"SYSTEM: {spawn_result}")
            logger.info("Spawn result => %s", spawn_result)

        # 6) Print a final summary
        summary_msg = (f"SYSTEM: Attempted to spawn {count} bots, {successes} succeeded. Done.")
        print(summary_msg)
        logger.info(summary_msg)

    # 7) We do a blocking run of do_spawn on the given loop
    print(f"SYSTEM: Summoning a squad of {count} persona(s) for theme: '{theme}'... stand by.")
    logger.info("cmd_spawn_squad => scheduling do_spawn (count=%d, theme=%r)", count, theme)

    future = asyncio.run_coroutine_threadsafe(do_spawn(), loop)

    # Instead of returning immediately, we BLOCK on that future so you see everything in order
    try:
        result = future.result()  # This blocks until do_spawn() completes
        print("[DEBUG] do_spawn() completed =>", result)
        logger.debug("do_spawn completed => result=%r", result)
    except Exception as e:
        print(f"SYSTEM: spawn_squad encountered an error => {e}")
        logger.exception("spawn_squad encountered an exception =>", exc_info=e)
