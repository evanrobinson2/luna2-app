# bot_message_handler.py

import logging
import os
import time
import pandas as pd
from nio import RoomMessageText, RoomSendResponse

logger = logging.getLogger(__name__)

# Path to your CSV file of all messages
MESSAGES_CSV = "data/luna_messages.csv"

async def handle_bot_room_message(bot_client, bot_localpart, room, event):
    """
    A specialized callback for a single bot's RoomMessageText events.

    Inbound Flow:
      1) Ensure event is a text message; ignore otherwise.
      2) Ignore if the sender == this bot (avoid self-loop).
      3) Check if this inbound event is new (store_inbound_message).
         - If it's a duplicate, skip further processing.
      4) If direct chat (2 participants), auto-reply.
      5) If group chat, only reply if the bot is mentioned.
      6) Save any outbound reply to CSV (store_outbound_message).

    :param bot_client: The AsyncClient for this particular bot.
    :param bot_localpart: e.g. "inky", "wild_horse" (no '@' or ':...')
    :param room: The matrix-nio room object.
    :param event: The matrix-nio event object (RoomMessageText).
    """

    # 1) Check event type
    if not isinstance(event, RoomMessageText):
        logger.debug("Not a text message event. Skipping.")
        return

    # 2) Avoid responding to ourselves
    bot_full_id = bot_client.user  # e.g. "@wild_horse:localhost"
    if event.sender == bot_full_id:
        logger.debug(f"Bot '{bot_localpart}' ignoring its own message in {room.room_id}")
        return

    # 3) Check for duplicates in the CSV; if found, skip
    is_new = await store_inbound_message(room, event)
    if not is_new:
        logger.info(f"[handle_bot_room_message] Duplicate message => event_id={event.event_id}. Skipping.")
        return

    # 4) Gather details for logic
    participant_count = len(room.users)
    user_text = event.body or ""
    mention_data = event.source.get("content", {}).get("m.mentions", {})
    mentioned_ids = mention_data.get("user_ids", [])
    logger.debug(
        f"[handle_bot_room_message] Bot '{bot_localpart}' => "
        f"user_text='{user_text}', mention_data={mention_data}, participant_count={participant_count}"
    )

    # 5) Direct chat? => auto-reply
    if participant_count == 2:
        reply_text = (
            f"Hi from '{bot_localpart}' (DM). "
            f"You said: '{user_text[:50]}...'"
        )
        resp = await bot_client.room_send(
            room_id=room.room_id,
            message_type="m.room.message",
            content={"msgtype": "m.text", "body": reply_text},
        )
        # Log it in the CSV
        if resp and isinstance(resp, RoomSendResponse) and resp.event_id:
            await store_outbound_message(room.room_id, bot_full_id, reply_text, resp.event_id)
        else:
            # fallback if we didn't get an event_id
            fallback_id = f"{bot_full_id}-{time.time_ns()}"
            await store_outbound_message(room.room_id, bot_full_id, reply_text, fallback_id)
        logger.info(f"Bot '{bot_localpart}' posted a DM reply to {room.room_id}")
        return

    # 6) Group chat => only respond if we're in m.mentions
    if bot_full_id in mentioned_ids:
        reply_text = (
            f"Hello from '{bot_localpart}' in a group chat! "
            f"I see you mentioned me: '{user_text[:50]}...'"
        )
        resp = await bot_client.room_send(
            room_id=room.room_id,
            message_type="m.room.message",
            content={"msgtype": "m.text", "body": reply_text},
        )
        if resp and isinstance(resp, RoomSendResponse) and resp.event_id:
            await store_outbound_message(room.room_id, bot_full_id, reply_text, resp.event_id)
        else:
            fallback_id = f"{bot_full_id}-{time.time_ns()}"
            await store_outbound_message(room.room_id, bot_full_id, reply_text, fallback_id)

        logger.info(f"Bot '{bot_localpart}' posted a mention-based reply to {room.room_id}")
    else:
        logger.debug(
            f"Bot '{bot_localpart}' ignoring group message with no mention in {room.room_id}"
        )


# ------------------------------------------------------------------
# CSV Storage Helpers
# ------------------------------------------------------------------

async def store_inbound_message(room, event) -> bool:
    """
    Stores the inbound message in MESSAGES_CSV if it's not a duplicate.
    Returns True if newly added, False if it was already there.
    """
    new_record = {
        "room_id": room.room_id,
        "event_id": event.event_id,
        "sender": event.sender,
        "timestamp": event.server_timestamp,
        "body": event.body or ""
    }

    df_new = pd.DataFrame([new_record])

    logger.info("[store_inbound_message] Attempting to store a message!")
    if not os.path.exists(MESSAGES_CSV):
        # If CSV doesn't exist yet, create it with this single row
        df_new.to_csv(MESSAGES_CSV, index=False)
        logger.info(f"[store_inbound_message] Created {MESSAGES_CSV} with event_id={event.event_id}.")
        return True

    # Otherwise, read existing and check duplicates
    try:
        existing_df = pd.read_csv(MESSAGES_CSV)
        logger.debug(f"[store_inbound_message] Loaded {len(existing_df)} rows from {MESSAGES_CSV}.")
    except pd.errors.EmptyDataError:
        # If CSV was empty, treat it as an empty DF
        existing_df = pd.DataFrame(columns=["room_id", "event_id", "sender", "timestamp", "body"])
        logger.warning(f"[store_inbound_message] {MESSAGES_CSV} is empty. Using fresh columns.")

    before_count = len(existing_df)
    combined_df = pd.concat([existing_df, df_new], ignore_index=True)
    combined_df.drop_duplicates(subset=["room_id", "event_id"], keep="last", inplace=True)
    after_count = len(combined_df)

    if after_count > before_count:
        # We added a new row
        combined_df.to_csv(MESSAGES_CSV, index=False)
        logger.info(f"[store_inbound_message] Appended new inbound record => event_id={event.event_id}.")
        return True
    else:
        logger.debug(f"[store_inbound_message] Duplicate event_id={event.event_id}; skipping.")
        return False


async def store_outbound_message(room_id: str, sender: str, body: str, event_id: str):
    """
    Appends an outbound message to MESSAGES_CSV if it's not a duplicate.
    If event_id is None, we generate a fallback with time_ns().
    """
    if not event_id:
        # fallback to keep uniqueness
        event_id = f"{sender}-{time.time_ns()}"

    new_record = {
        "room_id": room_id,
        "event_id": event_id,
        "sender": sender,
        "timestamp": int(time.time() * 1000),
        "body": body
    }
    df_new = pd.DataFrame([new_record])

    if not os.path.exists(MESSAGES_CSV):
        df_new.to_csv(MESSAGES_CSV, index=False)
        logger.info(f"[store_outbound_message] Created {MESSAGES_CSV} and stored outbound event_id={event_id}.")
        return

    try:
        existing_df = pd.read_csv(MESSAGES_CSV)
    except pd.errors.EmptyDataError:
        existing_df = pd.DataFrame(columns=["room_id", "event_id", "sender", "timestamp", "body"])
        logger.warning(f"[store_outbound_message] {MESSAGES_CSV} is empty. Using fresh columns.")

    before_count = len(existing_df)
    combined_df = pd.concat([existing_df, df_new], ignore_index=True)
    combined_df.drop_duplicates(subset=["room_id", "event_id"], keep="last", inplace=True)
    after_count = len(combined_df)

    if after_count > before_count:
        combined_df.to_csv(MESSAGES_CSV, index=False)
        logger.info(
            f"[store_outbound_message] Appended outbound => event_id={event_id}, sender={sender}. "
            f"Total now {len(combined_df)} rows."
        )
    else:
        logger.debug(f"[store_outbound_message] Detected duplicate outbound event_id={event_id}; skipping.")
