"""
luna.py

- Configures logging (console + file)
- Creates one main event loop
- Spawns the console in a background thread (reads user commands, schedules coroutines)
- Runs the 'main_logic' which logs in (reusing token or password) and syncs forever
"""

import asyncio
import sys
import json
import os
import logging
import threading
from src.console_apparatus import console_loop
from src.luna_command_extensions.cmd_shutdown import init_shutdown, SHOULD_SHUT_DOWN
from src.luna_command_extensions.bot_invite_handler import handle_bot_invite
from src.luna_command_extensions.bot_message_handler import handle_bot_room_message
from src.luna_functions import load_or_login_client_v2
#
# Trying to replace this with a new one
# from src.luna_functions_handledispatch import on_room_message
from src.luna_command_extensions.handle_dispatch2 import on_room_message

from src.luna_functions import fetch_all_messages_once
from nio import RoomMessageText, InviteMemberEvent, AsyncClient
from src.luna_functions import (
    on_invite_event,
    load_or_login_client
)

# We'll store the main event loop globally so both the console thread
# and the Director logic can access it.
MAIN_LOOP = None
REFRESH_INTERVAL_SECONDS = 10

# We’ll store the in-memory references here:
BOTS = {}      # localpart -> AsyncClient
bot_tasks = [] # list of asyncio tasks (one per bot’s sync loop)

def configure_logging():
    """
    Configure Python's logging so logs go to both console and server.log.
    """
    global logger
    logger = logging.getLogger(__name__)
    logging.getLogger("nio.responses").setLevel(logging.CRITICAL)
    logger.debug("Entering configure_logging function.")

    root_logger = logging.getLogger()
    root_logger.setLevel(logging.DEBUG)  # Overall log level
    logger.debug("Set root logger level to DEBUG.")

    formatter = logging.Formatter("%(asctime)s [%(levelname)s] %(name)s: %(message)s")
    logger.debug("Formatter for logs created.")

    file_handler = logging.FileHandler("data/logs/server.log", mode="a")  # Append to server.log
    file_handler.setLevel(logging.DEBUG)  # Store everything (DEBUG+) in the file
    file_handler.setFormatter(formatter)
    root_logger.addHandler(file_handler)
    logger.debug("Added file handler to root logger. Logging to 'server.log' at DEBUG level.")

    logger.debug("Exiting configure_logging function.")

def start_console_thread(loop):
    """
    Spawn the console input loop in a background thread,
    passing in `loop` so commands can schedule tasks on that loop.
    """
    logger = logging.getLogger(__name__)
    logger.debug("Entering start_console_thread function.")

    try:
        thread = threading.Thread(target=lambda: console_loop(loop), daemon=True)
        thread.start()
        logger.info("Console thread started successfully.")
    except Exception as e:
        logger.exception(f"Failed to start console thread: {e}")

    logger.debug("Exiting start_console_thread function.")

async def main_logic():
    logger = logging.getLogger(__name__)
    logger.debug("Entering main_logic function...")

    # 1. Acquire client (Luna's own client)
    client: AsyncClient = await load_or_login_client(
        homeserver_url="http://localhost:8008",
        username="lunabot",
        password="12345"
    )

    # 2. Register callbacks on Luna's client
    client.add_event_callback(on_room_message, RoomMessageText)
    client.add_event_callback(on_invite_event, InviteMemberEvent)

    # 3. Load and log in all existing bots from personalities.json
    await login_bots()
    logger.debug(f"BOTS loaded => {list(BOTS.keys())}")

    # 4. For each bot, register message/invite handlers, then spin up a sync task
    bot_tasks = []
    for localpart, bot_client in BOTS.items():
        try:
            # Register message callback
            bot_client.add_event_callback(
                lambda r, e: handle_bot_room_message(bot_client, localpart, r, e),
                RoomMessageText
            )
            logger.info(f"Registered message handler for bot '{localpart}'")

            # Register invite callback
            bot_client.add_event_callback(
                lambda r, e: handle_bot_invite(bot_client, localpart, r, e),
                InviteMemberEvent
            )
            logger.info(f"Registered invite handler for bot '{localpart}'")

            # Create an asyncio Task for this bot's sync loop
            bot_task = asyncio.create_task(run_bot_sync(bot_client, localpart))
            bot_tasks.append(bot_task)

        except Exception as e:
            logger.exception(f"Failed to set up bot '{localpart}': {e}")

    # 5. Meanwhile, Luna's own sync loop
    logger.debug("Starting Luna's main short sync loop; will exit when SHOULD_SHUT_DOWN = True.")
    while not SHOULD_SHUT_DOWN:
        try:
            # A single sync for Luna that times out after 5 seconds
            await client.sync(timeout=5000)
        except Exception as e:
            logger.exception(f"Error in Luna's own client.sync: {e}")

    # 6. Shutting down: stop Luna's sync, stop bots’ sync tasks, close connection
    logger.info("main_logic loop exiting. Closing Luna's client connection...")
    await client.close()
    logger.debug("Luna's client closed.")

    # Optionally, you might also cancel each bot’s task here
    for task in bot_tasks:
        task.cancel()
    # You could then await them, e.g. in a try/except to absorb cancellation
    # for task in bot_tasks:
    #     try:
    #         await task
    #     except asyncio.CancelledError:
    #         pass

    logger.debug("main_logic() is returning.")

# Helper: a simple sync loop for each bot
async def run_bot_sync(bot_client, localpart):
    from src.luna_command_extensions.cmd_shutdown import SHOULD_SHUT_DOWN
    logger = logging.getLogger(__name__)

    # This loop runs until SHOULD_SHUT_DOWN is set to True
    while not SHOULD_SHUT_DOWN:
        try:
            await bot_client.sync(timeout=5000)
        except Exception as e:
            logger.exception(f"Bot '{localpart}' encountered a sync error: {e}")
            await asyncio.sleep(2)  # a small backoff
        else:
            # If everything went fine, yield control briefly
            await asyncio.sleep(0)

def luna():
    """
    Orchestrates everything:
    - Configure logging
    - Create the main event loop
    - Start the console thread (which schedules coroutines on the loop)
    - Run `main_logic()` until complete (i.e., forever, unless Ctrl+C, etc.)
    """
    logger = logging.getLogger(__name__)
    logger.debug("Entering luna() function.")

    # 1. Configure logging
    configure_logging()
    logger.debug("Logging configuration complete.")

    # 2. Create our own event loop
    logger.debug("Creating a new asyncio event loop.")
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    logger.debug("Set this new loop as the default event loop for the current thread.")

    # 2) Initialize shutdown helper with this loop
    init_shutdown(loop)

    global MAIN_LOOP
    MAIN_LOOP = loop  # Store in a global
    logger.debug("Stored reference to the new loop in MAIN_LOOP.")

    # 3. Start the console in a background thread
    start_console_thread(loop)
    logger.debug("Console thread has been initiated. Returning to main thread.")

    # 4. Run the main async logic (token-based login & sync) on this loop
    try:
        logger.info("Starting main_logic coroutine.")
        loop.run_until_complete(main_logic())
    except KeyboardInterrupt:
        logger.warning("KeyboardInterrupt received. Shutting down Director.")
    except Exception as e:
        logger.exception(f"An unexpected exception occurred in main_logic: {e}")
    finally:
        logger.debug("Preparing to close the event loop.")
        loop.close()
        logger.info("Event loop closed. Exiting main function.")

async def login_bots():
    """
    Reads 'data/luna_personalities.json', logs in each bot via ephemeral password,
    and stores the resulting AsyncClient in the global BOTS dict.

    Does NOT create any sync loops or callbacks yet. You can do that separately.
    """
    personalities_file = "data/luna_personalities.json"
    if not os.path.exists(personalities_file):
        logger.error(f"[login_bots] File not found: {personalities_file}")
        return

    # Load the JSON
    with open(personalities_file, "r") as f:
        personalities_data = json.load(f)

    homeserver_url = "http://localhost:8008"

    # Iterate each user in the JSON
    for user_id, persona in personalities_data.items():
        # user_id might be something like "@inky:localhost"
        localpart = user_id.split(":")[0].replace("@", "")  # "inky", etc.
        password = persona.get("password")
        if not password:
            logger.warning(f"[login_bots] Skipping {user_id}, no password found.")
            continue

        try:
            logger.info(f"[login_bots] Logging in bot => user_id={user_id}, localpart={localpart}")
            client: AsyncClient = await load_or_login_client_v2(
                homeserver_url=homeserver_url,
                user_id=user_id,   # the full ID
                password=password,
                device_name=f"{localpart}_device"
            )
            # Store it in our global BOTS dict
            BOTS[localpart] = client

        except Exception as e:
            logger.exception(f"[login_bots] Failed to login {user_id} => {e}")

    logger.info(f"[login_bots] Completed ephemeral login for {len(BOTS)} bot(s).")


if __name__ == "__main__":
    luna()
